knitr::opts_chunk$set(echo = TRUE)
library(pacman)
pacman::p_load(tidyverse,
rstanarm,
bayesplot,
RColorBrewer)
# Setting some colors
colours <- brewer.pal(n = 8, name = 'Set1')
# And setting a seed bc nice and reproducible
set.seed(0)
data <- tibble(y = rnorm(10000))
quantile(data$y)
plot <- ggplot(data,aes(x=y)) +
geom_density()
plot
n <- 10
const <- rep(1,n)
x <- 1:10
X <- cbind(const, x)
X
b <- c(2, 0.5)
b
ystar <- X %*% b
tibble(x, ystar) %>%
ggplot(aes(x = x, y = ystar)) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point(colour = colours[2]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(y = "y")# +
#scale_colour_brewer(palette = "Set1")
set.seed(0)
err = rnorm(10)
err
data <- tibble(x = X[,2], y = y[,1])
y <- X %*% b + err
y
data <- tibble(x = X[,2], y = y[,1])
data
bind_rows(data, bind_cols(x = x, y = ystar[,1]), .id = "noise") %>%
ggplot(aes(x = x, y = y, colour = factor(noise, labels = c("y", "ystar")))) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point() +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(colour = "Noise") +
scale_colour_brewer(palette = "Set1")
estimates <- solve(t(x)%*%x)%*%t(x)%*%y
View(y)
#implementing OLS equation with base R
x_new <- solve(t(A) %*% A) %*% t(A) %*% y #calculating new weights
remotes::install_github("avehtari/ROS-Examples", subdir = "rpackage")
library(rosdata, dplyr)
df <- dplyr::select(kidiq, kid_score, mom_iq, mom_age) #creating dataframe
head(df)
#creating matrix
A <- cbind(1,df$mom_iq,df$mom_age)
dim(A) #showing number of rows and columns
#setting values
intercept <- 16.0
mom_iq_weight <- 0.55
mom_age_weight <- 0.45
x <- c(intercept,mom_iq_weight,mom_age_weight)
y <- df$kid_score
#predicting outcome variable using matrix multiplication
y_hat <- A %*% x
#function for calculating residual sum of squares
rss_func <- function(y, y_hat) {
residuals <- y - y_hat
rss <- sum(residuals ^ 2)
return(rss)
}
#inputting our values to the function
rss <- rss_func(y,y_hat)
#implementing OLS equation with base R
x_new <- solve(t(A) %*% A) %*% t(A) %*% y #calculating new weights
#creating new predictions
y_hat_new <- A %*% x_new
#computing errors for new predictions
rss_new <- rss_func(y,y_hat_new)
#creating model
model <- lm(kid_score ~ mom_iq, df)
model
summary(model)
intercept_lm <- coef(model)[1]
slope_lm <- coef(model)[2]
#predicting values with a linear model
y_preds <- intercept_lm + slope_lm * df$mom_iq
r_squared_func <- function(y, y_preds) {
residuals <- y - y_preds
rss <- sum(residuals ^ 2)
variance <- y - mean(y)
tss <- sum(variance ^ 2)
r_squared <- 1 - (rss / tss)
return(r_squared)
}
r_squared <- r_squared_func(y, y_preds)
r_squared
View(x_new)
estimates <- solve(t(X) %*% X) %*% t(X) %*% y
library(pacman)
pacman::p_load(tidyverse,
rstanarm,
bayesplot,
RColorBrewer)
# Setting some colors
colours <- brewer.pal(n = 8, name = 'Set1')
# And setting a seed bc nice and reproducible
set.seed(0)
data <- tibble(y = rnorm(10000))
quantile(data$y)
plot <- ggplot(data,aes(x=y)) +
geom_density()
plot
n <- 10
const <- rep(1,n)
x <- 1:10
X <- cbind(const, x)
X
b <- c(2, 0.5)
b
ystar <- X %*% b
tibble(x, ystar) %>%
ggplot(aes(x = x, y = ystar)) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point(colour = colours[2]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(y = "y")# +
#scale_colour_brewer(palette = "Set1")
set.seed(0)
err = rnorm(10)
err
y <- X %*% b + err
y
data <- tibble(x = X[,2], y = y[,1])
data
bind_rows(data, bind_cols(x = x, y = ystar[,1]), .id = "noise") %>%
ggplot(aes(x = x, y = y, colour = factor(noise, labels = c("y", "ystar")))) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point() +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(colour = "Noise") +
scale_colour_brewer(palette = "Set1")
estimates <- solve(t(X) %*% X) %*% t(X) %*% y
estimates
bhat <- solve(t(X) %*% X) %*% t(X) %*% y
bhat
ggplot(data, aes(x = x, y = y)) +
geom_point(colour = colours[1]) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_abline(intercept = bhat[1], slope = bhat[2], colour = colours[1]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10))
ggplot(data, aes(x = x, y = y)) +
geom_point(colour = colours[1]) +
geom_abline(intercept = bhat[1], slope = bhat[2], colour = colours[1]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10))
ggplot(data, aes(x = x, y = y)) +
geom_point(colour = colours[1]) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_abline(intercept = bhat[1], slope = bhat[2], colour = colours[1]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10))
View(data)
lm(y ~ x, data)
b <- c(2.375, 0.005)
sigma <- 0.4
n_samples <- 256
household_incomes <- runif(n_samples, min = 15000, max = 300000)
mean_GPA <- 2.7
preds_GPA <- c[1] + c[2] * household_incomes + rnorm(n_samples,0,sigma)
preds_GPA <- b[1] + b[2] * household_incomes + rnorm(n_samples,0,sigma)
plot1 <- ggplot(preds_GPA) +
geom_point() +
geom_abline(intercept = b[1], slope = b[2])
data <- data.frame(x=household_incomes,y=preds_GPA)
plot1 <- ggplot(data) +
geom_point() +
geom_abline(intercept = b[1], slope = b[2])
plot1
data <- data.frame(x=household_incomes,y=preds_GPA)
plot1 <- ggplot(data) +
geom_point() +
geom_abline(intercept = b[1], slope = b[2])
plot1
plot1 <- ggplot(data,aes(x=x,y=y)) +
geom_point() +
geom_abline(intercept = b[1], slope = b[2])
plot1
preds_GPA <- b[1] + b[2] * household_incomes + rnorm(n_samples,0,sigma)
sigma <- 0.4
preds_GPA <- b[1] + b[2] * household_incomes + rnorm(n_samples,0,sigma)
data <- data.frame(x=household_incomes,y=preds_GPA)
plot1 <- ggplot(data,aes(x=x,y=y)) +
geom_point() +
geom_abline(intercept = b[1], slope = b[2])
plot1
preds_GPA <- b[1] + b[2] * ((household_incomes - 65000) / 20000) + rnorm(n_samples,0,sigma)
data <- data.frame(x=household_incomes,y=preds_GPA)
plot1 <- ggplot(data,aes(x=x,y=y)) +
geom_point() +
geom_abline(intercept = b[1], slope = b[2])
plot1
n_samples <- 256
household_incomes <- runif(n_samples, min = 15000, max = 300000)
mean_GPA <- 2.7
preds_GPA <- b[1] + b[2] * ((household_incomes - 65000) / 20000) + rnorm(n_samples,0,sigma)
data <- data.frame(x=household_incomes,y=preds_GPA)
plot1 <- ggplot(data,aes(x=x,y=y)) +
geom_point() +
geom_abline(intercept = b[1], slope = b[2])
plot1
